const fs = require('fs');
const path = require('path');
const refs = require('./refs.json');

const remark = require('remark');
const remarkGfm = require('remark-gfm');
const visit = require('unist-util-visit');

const refKeys = Object.keys(refs);

const excluded = token => {
  if (
    token.includes('_') ||
    token.includes('-') ||
    token.includes('=') ||
    token.match(/^[0-9]/) ||
    token.match(/^[A-Za-z]$/) ||
    token.match(/^'[A-Za-z]'$/) ||
    [
      'DELETE',
      ',',
      'POST',
      '.then',
      '...rest',
      'onerror',
      'onload',
      'touch',
      'upperRest',
      'onmessage',
      'PUT',
      'x / y',
      'error',
      'length',
      'event',
      'eventType',
      'x1',
      "'afterend'",
      "'beforebegin'",
      'text/css',
      "'click'",
      "'mousemove'",
      "'ontouchstart'",
      "'scroll'",
      "'touchstart'",
      "'undefined'",
      '**',
      '\\n',
      '&',
      '&&',
      '#',
      '%',
      '^',
      '<',
      '<<',
      '>',
      '||',
      '~',
      'x2',
      'y1',
      '""',
      'y2',
      "'#'",
      'year',
      'GET',
      '{ once: true }',
      "{ weekday: 'long' }",
      "'[object AsyncFunction]'",
      "'[object GeneratorFunction]'",
      'TRAVIS',
      'CI',
      'fn',
      'fns',
      'num',
      'nums',
      'arr',
      'count',
      'data',
      'date',
      'diff',
      'emit',
      'end',
      'start',
      'resolve',
      'responseText',
      'searchString',
      'seen',
      'first',
      'last',
      'id',
      'listener',
      'mode',
      'opts',
      'src',
      'target',
      'lim',
      'lim / n',
      'ms',
      'n -1',
      'next',
      "'no'",
      "'null'",
      "'object'",
      'nth',
      '.json',
      'startDate',
      'stop',
      'sum',
      'targets',
      'text',
      'object',
      'pattern',
      'pred',
      'predicate',
      'prop',
      'props',
      'url',
      'wait',
      'val',
      'values',
      'walk',
      'weights',
      'word',
      'str',
      'step',
      'size',
      'am',
      'array',
      'async',
      'called',
      'pipe',
      'pivot',
      'power',
      'centroids',
      'click',
      'columns',
      'comparator',
      'compare',
      'dark',
      'day',
      'decimals',
      'deepFreeze()',
      'delimiter',
      'depth',
      'direction',
      'el',
      'epsilon',
      'false',
      'filter',
      'function',
      'HH:MM:SS',
      'hour',
      'hsl()',
      'pending',
      'if',
      'indent',
      'index',
      'indexes',
      'inherited',
      'initializeNDArray()',
      'iterations',
      'key',
      'keys',
      'lastSpace',
      'light',
      'link',
      'lookup',
      'options',
      'mapString',
      'queryString',
      'quickSort()',
      'radix',
      'reject',
      'replacement',
      'max',
      'month',
      'mouse',
      'n - 1',
      'node',
      'heapify',
      'hexes',
      'htmlString',
      'normalized',
      'obj',
      'on',
      'order',
      'form',
      'orders',
      'outMin',
      'includeDuplicates',
      'inThrottle',
      'item',
      'iterable',
      'json',
      'keysMap',
      'number',
      'obj[target]',
      'offset',
      'omitFirstRow',
      'pad()',
      'parent',
      'partials',
      'plural',
      'point',
      'precision',
      'prefix',
      'endDate',
      'equals()',
      'queryParameters',
      'rgb()',
      'running',
      'dateEnd',
      'dateStart',
      'hub',
      'searchValue',
      'seed',
      'separator',
      'swapped',
      'transforms',
      'true',
      'type',
      'lowerRest',
      'match',
      'matcher',
      'mergeSort()',
      'usePopulation',
      'while',
      'valid',
      'chunk',
      'clear',
      'decrypt',
      'def',
      'defaultLang',
      'delay',
      'value',
      'off',
      'outMax',
      'pm',
      '<li>',
      '<textarea>',
      'addSpace',
      'br',
      '+',
      'comp',
      'condition',
      'clone',
      'container',
      'context',
      'context[fn]',
      'converger',
      'delCount',
      'distances',
      'ending',
      'err',
      'func',
      'element',
      'label',
      'mask',
      'minute',
      'off',
      'detail',
      'dig',
      'display',
      'display: none',
      'add',
      'args',
      'arguments',
      'arity',
      'arr[0]',
      'autoStart',
      'await',
      'buckets',
      'cache',
      'callback',
      'char',
      'duration',
      'outMax',
      'pm',
      'rgba()',
      'string',
      'symbol',
      'valid',
      'value',
      'classes',
      'elements',
      'inMin',
      'name',
      'rule',
      'second',
      'style',
      'styles',
      "' '",
      "','",
      "'?'",
      "'...'",
      "'*'",
      "'\\n'",
      "'\\r\\n'",
      '!',
      '?',
      "'&'",
      "'asc'",
      "'y'",
      '(end - start + 1) / step',
      '(n * (n + 1)) / 2',
      '[]',
      "{ behavior: 'smooth' }",
      '{}',
      '<img>',
      'body',
      'inMax',
      'itr',
      'millisecond',
      'nextSeed',
      'selector',
      "'yes'",
      'sign',
    ].includes(token)
  ) {
    return true;
  }
  return false;
};

// Setup Remark using the appropriate options.
const remarkOptions = {
  commonmark: true,
  footnotes: true,
  gfm: true,
  pedantic: true,
};
const remarkParser = new remark()
  .use(remarkGfm)
  .data('settings', remarkOptions);

const parseMarkdown = markdown => {
  const ast = remarkParser.parse(markdown);

  let inlineBlocks = new Set();
  // Highlight inline code blocks
  visit(ast, `inlineCode`, node => {
    if (!excluded(node.value) && !refKeys.includes(node.value))
      inlineBlocks.add(node.value);
  });

  return inlineBlocks;
};

const directory = './content/sources/30code/snippets';
const snippetNames = fs.readdirSync(directory);

let codeBlocks = new Set();

for (let snippet of snippetNames) {
  const snippetPath = path.join(directory, snippet);
  const snippetContent = fs.readFileSync(snippetPath, 'utf8');
  let blockies = [...parseMarkdown(snippetContent)];
  // if (blockies.length)
  //   console.log(
  //     `${snippet}: ${blockies.join(', ')} - ${[...codeBlocks].join('/')}`
  //   );
  blockies.forEach(block => codeBlocks.add(block));
}

const isUpperCase = str => str === str.toUpperCase();

fs.writeFileSync(
  '30code2.json',
  JSON.stringify(
    Array.from(codeBlocks).sort((a, b) => {
      if (isUpperCase(a[0]) && !isUpperCase(b[0])) return -1;
      if (!isUpperCase(a[0]) && isUpperCase(b[0])) return 1;
      return a.localeCompare(b);
    }),
    null,
    2
  )
);
